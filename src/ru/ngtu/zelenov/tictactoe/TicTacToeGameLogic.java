package ru.ngtu.zelenov.tictactoe;

// Класс Логики игры
// Отвечает за правила и состояние игры
class TicTacToeGameLogic {

    // Состояние Игры

    // Модель игрового поля: 3x3 массив.
    // 0 - пусто, 1 - игрок 'X', 2 - компьютер 'O'.
    // private - доступ только внутри этого класса (инкапсуляция).
    private int[][] model = new int[3][3];

    // Текущий игрок: 1 (Человек 'X') или 2 (Компьютер 'O').
    private int currentPlayer;

    // Флаг, показывающий, завершена ли игра (победа или ничья).
    private boolean isGameStopped;

    // Методы для Доступа к cостоянию

    public int[][] getModel() {
        return model; // Возвращает ссылку на массив модели
    }

    public int getCurrentPlayer() {
        return currentPlayer; // Возвращает номер текущего игрока
    }

    public boolean isGameStopped() {
        return isGameStopped; // Возвращает true, если игра остановлена, иначе false
    }

    // Основные Методы Игровой Логики

    /**
     * Начинает или перезапускает игру.
     * Сбрасывает игровое поле, устанавливает первого игрока (X) и снимает флаг остановки.
     */
    public void startGame() {
        currentPlayer = 1;      // Игрок 1 (X) ходит первым
        isGameStopped = false;  // Игра активна

        // Очищаем модель поля (все клетки устанавливаем в 0 - пусто)
        for (int x = 0; x < 3; x++) {
            for (int y = 0; y < 3; y++) {
                model[x][y] = 0;
            }
        }

    }

    /**
     * Вспомогательный метод для получения символа клетки ("X", "O", " ").
     * для отображения правильного символа на кнопках.
     */
    public String getSymbol(int value) {
        if (value == 1) {
            return "X"; // Игрок
        } else if (value == 2) {
            return "O"; // Компьютер
        } else {
            return " "; // Пустая клетка
        }
    }

    /**
     * Проверяет, есть ли на поле хотя бы одна пустая клетка.
     */
    public boolean hasEmptyCell() {
        for (int x = 0; x < 3; x++) {
            for (int y = 0; y < 3; y++) {
                if (model[x][y] == 0) {
                    return true; // Нашли пустую - значит, есть куда ходить
                }
            }
        }
        return false; // Пустых клеток нет
    }

    /**
     * Обрабатывает ход текущего игрока в указанные координаты.
     * делает пять проверок
     */
    public boolean processMove(int x, int y) {
        // Проверка 1: игра уже остановлена? Клетка вне поля? Клетка уже занята?
        if (isGameStopped || x < 0 || x > 2 || y < 0 || y > 2 || model[x][y] != 0) {
            return false; // Ход невозможен, игра не меняется
        }

        // Проверка 2: ставим символ текущего игрока (1 или 2)
        model[x][y] = currentPlayer;

        // Проверка 3: проверяем победу текущего игрока после этого хода
        if (checkBoardWin(currentPlayer)) {
            isGameStopped = true; // Останавливаем игру
            return true; // Сигнализируем, что игра закончилась (победой)
        }

        // Проверка 4: если победы нет, проверяем на ничью (нет пустых клеток?)
        if (!hasEmptyCell()) {
            isGameStopped = true; // Останавливаем игру
            return true; // Сигнализируем, что игра закончилась (ничьей)
        }

        // Проверка 5: если игра не закончилась, передаем ход другому игроку
        // (Если был 1, станет 2; если был 2, станет 1)
        currentPlayer = 3 - currentPlayer;
        return false; // Сигнализируем, что игра продолжается
    }

    /**
     * Выбирает и возвращает координаты для хода компьютера.
     * Реализует (выиграть, блокировать, взять центр, взять угол, взять сторону)
     * только выбирает, но не делает
     */
    public int[] computerTurn() {
        if (isGameStopped) {
            return null; // Не выбирать ход, если игра остановлена
        }

        // Важно: currentPlayer здесь ДОЛЖЕН быть равен 2 (компьютер),
        // так как этот метод вызывается после хода игрока и смены игрока в processMove.

        // 1. Найти выигрышный ход для компьютера (currentPlayer = 2)
        for (int x = 0; x < 3; x++) {
            for (int y = 0; y < 3; y++) {
                if (checkFutureWin(x, y, currentPlayer)) { // Если ход в (x,y) приведет к победе O
                    return new int[]{x, y}; // Вернуть эти координаты
                }
            }
        }

        // 2. Найти ход, чтобы заблокировать выигрыш игрока (player = 1)
        int player = 3 - currentPlayer; // Игрок, которого надо блокировать (это 1)
        for (int x = 0; x < 3; x++) {
            for (int y = 0; y < 3; y++) {
                if (checkFutureWin(x, y, player)) { // Если игрок X МОГ БЫ выиграть, пойдя в (x,y)
                    return new int[]{x, y}; // Вернуть эти координаты, чтобы компьютер пошел туда
                }
            }
        }

        // 3. Занять центр, если свободен
        if (model[1][1] == 0) {
            return new int[]{1, 1};
        }

        // 4. Занять свободный угол
        int[] corners = {0, 0, 0, 2, 2, 0, 2, 2}; // Координаты углов: (0,0), (0,2), (2,0), (2,2)
        for (int i = 0; i < corners.length; i += 2) {
            int x = corners[i];
            int y = corners[i + 1];
            if (model[x][y] == 0) { // Если угол свободен
                return new int[]{x, y};
            }
        }

        // 5. Занять любую свободную боковую клетку
        int[] sides = {0, 1, 1, 0, 1, 2, 2, 1}; // Координаты боковых клеток: (0,1), (1,0), (1,2), (2,1)
        for (int i = 0; i < sides.length; i += 2) {
            int x = sides[i];
            int y = sides[i + 1];
            if (model[x][y] == 0) { // Если боковая клетка свободна
                return new int[]{x, y};
            }
        }

        // Сюда доходим, только если что-то пошло не так
        // В качестве запасного варианта, вернем первую попавшуюся пустую клетку.
        for (int x = 0; x < 3; x++) {
            for (int y = 0; y < 3; y++) {
                if (model[x][y] == 0) {
                    return new int[]{x, y};
                }
            }
        }

        return null; // Ходов нет (хотя hasEmptyCell должна была это предотвратить)
    }

    /**
     * Проверяет, приводит ли гипотетический ход игрока 'n' в клетку (x, y) к победе.
     */
    public boolean checkFutureWin(int x, int y, int n) {
        // Можно проверять только пустые клетки
        if (model[x][y] != 0) {
            return false;
        }

        // Временно делаем ход
        model[x][y] = n;
        // Проверяем, возникла ли победа на всей доске после этого хода
        boolean isWin = checkBoardWin(n);
        // Отменяем временный ход, возвращая клетку в пустое состояние
        model[x][y] = 0;

        return isWin; // Возвращаем результат проверки
    }

    /**
     * Проверяет всё игровое поле на наличие выигрышной комбинации для игрока 'n'.
     */
    public boolean checkBoardWin(int n) {
        // Проверка всех 3-х горизонталей
        for (int x = 0; x < 3; x++) {
            if (model[x][0] == n && model[x][1] == n && model[x][2] == n) return true;
        }
        // Проверка всех 3-х вертикалей
        for (int y = 0; y < 3; y++) {
            if (model[0][y] == n && model[1][y] == n && model[2][y] == n) return true;
        }
        // Проверка главной диагонали (левый верх -> правый низ)
        if (model[0][0] == n && model[1][1] == n && model[2][2] == n) return true;
        // Проверка побочной диагонали (правый верх -> левый низ)
        if (model[0][2] == n && model[1][1] == n && model[2][0] == n) return true;

        // Если ни одна линия не совпала, выигрыша нет
        return false;
    }

}

